"""
################################################################################
# Copyright (c) SanDisk Corp.2022 - All rights reserved.This code, and all
# derivative work, is the exclusive property of SanDisk and may not be used
# without SanDisk's authorization.
#
# SCRIPTER PARENT SCRIPT         : None
# SCRIPTER SCRIPT                :
# CTF CALL ALL SCRIPT            : None
# CTF SCRIPT                     :
# CVF CALL ALL SCRIPT            : None
# CVF SCRIPT                     : SecurityUtils.py
# DESCRIPTION                    : This module contains all the functions required for Security Feature Validation
# PRERQUISTE                     :
# STANDALONE EXECUTION           : Yes
# TEST ARGUMENTS                 : --test=SecurityUtils.py --isModel=false --enable_console_log=1 --adapter=0
# Original PROGRAMMER            : Sandeep Singh
# UPDATED BY                     : Shalini HM and Punith Kumar P
# REVIEWED BY                    : None
# DATE                           : 08-Nov-2024
################################################################################
"""

from __future__ import division
from __future__ import absolute_import
from __future__ import print_function
from __future__ import unicode_literals


# Importing the required libraries
from future import standard_library
standard_library.install_aliases()
from builtins import str
from builtins import range
from builtins import *
from builtins import object
from past.utils import old_div
import shutil
import os.path
import Extensions.CVFImports as pyWrap
import Utils
import DiagnosticLib
import Core.ValidationError as TestError
import array
import time, datetime
import inspect
import sys, time, traceback, os, math, random, string
#import BotExploder
#from OpenSSL import crypto
import binascii
import hashlib
from Crypto.Hash import SHA256
from Crypto.Signature import PKCS1_v1_5
from Crypto.PublicKey import RSA

# SDDVT - Configuration Data
import SDDVT.Common.getconfig as getconfig
import SDDVT.Common.GlobalConstants as gvar
from SDDVT.Common.customize_log import customize_log

# CVF Packages
import SDCommandWrapper as sdcmdWrap
import CTFServiceWrapper as ServiceWrap
import Protocol.SD.Basic.TestCase as TestCase
import Core.Configuration as Configuration
import Core.ValidationError as ValidationError
import Validation.CVFTestFactory as FactoryMethod

# Python Build-in Modules
import random
import os
import sys
import time
from inspect import currentframe, getframeinfo
import struct
from struct import unpack, pack




SINGLE_SECTOR = 0x01
SECTOR_SIZE = 512
SINGLE_SECTOR_BUFFER = 512
MODEL_NUMBER_OFFSET = 0x36
MODEL_NUMBER_LENGTH = 40
UNSET_MASK = 0x0
DEVICESTATES = { 0x0 : 'DEVELOPMENT', 0x1: 'Locked', 0x2 : 'BRMA', 0x3: 'Unlock'}


SCTP_RSA_Signature = [
    [
    0x1D ,0x96 ,0x44 ,0x9D ,0x0F ,0xB3 ,0x5A ,0x91 ,0x8C ,0xC5 ,0xF9 ,0xFA ,0x14 ,0x69 ,0xF6 ,0x33 ,
    0xEB ,0x78 ,0xE2 ,0xEA ,0x6D ,0x3C ,0xF8 ,0x78 ,0x27 ,0xFE ,0xA7 ,0xCB ,0xF3 ,0x1E ,0xA6 ,0xD6 ,
    0x97 ,0xD5 ,0xE3 ,0xC6 ,0xAA ,0x42 ,0xDB ,0x3A ,0x52 ,0x26 ,0xA0 ,0x51 ,0x28 ,0x99 ,0x60 ,0x57 ,
    0x30 ,0x86 ,0xED ,0xEB ,0x66 ,0x67 ,0x4B ,0x6E ,0x0C ,0x4B ,0xBB ,0x03 ,0xDD ,0xDA ,0x8A ,0x7C ,
    0x32 ,0xD8 ,0xE3 ,0x51 ,0x70 ,0x69 ,0x2D ,0x0D ,0x6D ,0xDF ,0xEA ,0xD3 ,0x8B ,0x41 ,0x7A ,0x55 ,
    0xD8 ,0xD4 ,0x09 ,0x23 ,0x74 ,0xC5 ,0x5F ,0x31 ,0x4A ,0x23 ,0xED ,0x2B ,0x2A ,0xF4 ,0xCD ,0x15 ,
    0xF4 ,0x40 ,0xA0 ,0xDB ,0x92 ,0xC0 ,0xF4 ,0xD5 ,0x0A ,0x5C ,0x4B ,0x78 ,0xE4 ,0xE3 ,0xF7 ,0x96 ,
    0xE3 ,0xC7 ,0x01 ,0x04 ,0x8C ,0x8F ,0xA0 ,0x82 ,0x43 ,0x35 ,0xE5 ,0xC6 ,0xB0 ,0xE3 ,0xCC ,0x35 ,
    0x7E ,0x63 ,0x90 ,0xFE ,0x1E ,0x9C ,0xF1 ,0x18 ,0x8B ,0x78 ,0x79 ,0x81 ,0x83 ,0x3A ,0x59 ,0x57 ,
    0x6F ,0x83 ,0x83 ,0xBF ,0xDF ,0xA5 ,0x7F ,0x50 ,0x3E ,0x58 ,0xD9 ,0x17 ,0x45 ,0x08 ,0x19 ,0x24 ,
    0x69 ,0xDB ,0x4F ,0x5E ,0x6C ,0x41 ,0x62 ,0x95 ,0x93 ,0xB7 ,0x2F ,0xE2 ,0xA8 ,0x28 ,0x85 ,0x0A ,
    0x5B ,0xA5 ,0x7D ,0x0B ,0xBA ,0xD7 ,0x82 ,0x77 ,0xC5 ,0xDC ,0xDD ,0x13 ,0x96 ,0xEF ,0x6E ,0x43 ,
    0x8B ,0xC7 ,0xA8 ,0x97 ,0xFF ,0x36 ,0x46 ,0x65 ,0x53 ,0x5E ,0x4D ,0x90 ,0xC5 ,0xC7 ,0xCF ,0xDC ,
    0x70 ,0xC0 ,0xC6 ,0x85 ,0xE5 ,0xF8 ,0x2C ,0x9F ,0x12 ,0x7D ,0xB6 ,0x95 ,0x90 ,0xAE ,0x53 ,0x5B ,
    0x39 ,0x8A ,0x96 ,0xDB ,0x8F ,0x54 ,0x13 ,0xB9 ,0x32 ,0x68 ,0x71 ,0x8E ,0x2E ,0xE7 ,0xDB ,0x4B ,
    0xB2 ,0x4C ,0x95 ,0x8A ,0x36 ,0x4F ,0xF1 ,0xF1 ,0x47 ,0xEF ,0x3C ,0x2A ,0xFF ,0x16 ,0xE0 ,0xE8 , 
    ] ,
    [
    0xb6, 0xa1, 0xf5, 0xba, 0xfe, 0xd8, 0xff, 0x24, 0x20, 0x7f, 0x19, 0x4f, 0x8d, 0x9e, 0x00, 0x88,
    0x2f, 0xb9, 0x0a, 0x9e, 0x83, 0x53, 0x44, 0xe6, 0x4d, 0xcd, 0xb2, 0x79, 0x9d, 0xd8, 0x4d, 0x49,
    0xb5, 0x82, 0xfb, 0x1e, 0xd8, 0x40, 0x5d, 0x9c, 0x6f, 0xc7, 0x9e, 0x58, 0x55, 0xe5, 0xb5, 0x40,
    0x9e, 0x4b, 0x67, 0xb3, 0xd7, 0x17, 0x79, 0x9a, 0x7d, 0x97, 0xae, 0x84, 0x48, 0xf3, 0xf4, 0x0a,
    0xc9, 0x61, 0xf6, 0xdc, 0xe5, 0x6f, 0xfa, 0xea, 0x30, 0xbf, 0x43, 0x07, 0xa8, 0x4d, 0xb2, 0x27,
    0x6d, 0x49, 0x59, 0x4b, 0x42, 0xc2, 0x70, 0x1b, 0x5e, 0x62, 0xa7, 0x93, 0x15, 0x9f, 0x19, 0xe7,
    0xd0, 0xa2, 0x98, 0x56, 0x22, 0x5c, 0xaa, 0x03, 0x3c, 0x0d, 0x54, 0xaa, 0xaa, 0x6d, 0x3f, 0xa5,
    0x3c, 0x52, 0xf1, 0x98, 0xc5, 0xd3, 0x3b, 0x9d, 0x1f, 0x17, 0xe3, 0x10, 0x48, 0xd7, 0xbc, 0x2c,
    0xcc, 0x88, 0x30, 0x1b, 0x52, 0xb8, 0xe3, 0x83, 0xe8, 0x25, 0xa0, 0xed, 0x03, 0x81, 0xb7, 0xe0,
    0xa5, 0x1f, 0x66, 0x2d, 0x00, 0xac, 0xf7, 0x3d, 0x51, 0xd6, 0xce, 0x99, 0x51, 0xbd, 0x85, 0x9f,
    0x1b, 0x61, 0xd2, 0xe1, 0x8c, 0x4e, 0xf5, 0x7d, 0xe5, 0xa2, 0x0e, 0x87, 0xe8, 0x6b, 0x3c, 0x99,
    0xd2, 0xf3, 0x29, 0xc3, 0x3e, 0x1f, 0xfe, 0x30, 0x69, 0x64, 0xb2, 0xb5, 0xa8, 0xb4, 0xbb, 0x30,
    0xc9, 0x50, 0x94, 0x28, 0x91, 0x73, 0x93, 0xf1, 0x00, 0x81, 0x0b, 0xfc, 0x15, 0x0f, 0x41, 0xd6,
    0x2a, 0x65, 0x49, 0x6b, 0xa4, 0x8f, 0x64, 0xea, 0x8c, 0x38, 0x31, 0x8b, 0x2e, 0xc9, 0xe7, 0x6d,
    0xe1, 0x2b, 0x41, 0x54, 0x69, 0xbb, 0xe5, 0x33, 0x95, 0xda, 0xdd, 0x3d, 0xad, 0x33, 0x08, 0xa7,
    0x7b, 0x5a, 0xb4, 0x40, 0x73, 0xea, 0x7c, 0x61, 0xa5, 0x79, 0x9a, 0xd7, 0xe3, 0x12, 0xa5, 0xef,
    ]
]    
#######################################################################################################
# Keys for RMA
#######################################################################################################
#Use this key for PRMA/LRMA when engineering Keys are used
G_ROM_RSA_PublicKey = [
    0x30, 0x82, 0x01, 0x22, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01,
    0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0f, 0x00, 0x30, 0x82, 0x01, 0x0a, 0x02, 0x82, 0x01, 0x01,
    0x00, 0xc6, 0x3f, 0x9f, 0x29, 0x64, 0x2c, 0xc5, 0xc2, 0xf2, 0xc0, 0xba, 0x1c, 0xce, 0xed, 0x04,
    0x1d, 0x09, 0x56, 0x64, 0x07, 0x18, 0x90, 0x3f, 0x0a, 0x7f, 0xf2, 0x7d, 0xc8, 0x69, 0xe4, 0x8c,
    0x75, 0x35, 0x4c, 0x71, 0x92, 0xdf, 0x9f, 0xb7, 0xa5, 0x9e, 0x43, 0xfe, 0xd0, 0x18, 0x00, 0xc2,
    0xce, 0xbd, 0x5c, 0xe2, 0x46, 0xfb, 0xb3, 0x2c, 0xba, 0x6c, 0x24, 0x48, 0xb4, 0x2d, 0xdc, 0xef,
    0x5f, 0x5c, 0x80, 0x62, 0x07, 0x6d, 0xb9, 0xcb, 0xc1, 0x76, 0x95, 0x88, 0xcc, 0x1f, 0x15, 0x58,
    0xbb, 0x2b, 0xa3, 0x4c, 0xe4, 0xfb, 0xd9, 0xcb, 0xb5, 0x75, 0x88, 0x81, 0xfc, 0xa9, 0xb2, 0xca,
    0x38, 0xdd, 0x0f, 0x88, 0xc9, 0x41, 0x11, 0x57, 0xda, 0x01, 0x71, 0x29, 0x9c, 0xd6, 0x83, 0xaf,
    0x29, 0x5c, 0x96, 0x3e, 0x8d, 0x15, 0x68, 0xb7, 0x48, 0x97, 0xa0, 0x3f, 0xcd, 0x50, 0x79, 0x6b,
    0xcf, 0x31, 0xe7, 0x39, 0x27, 0xbe, 0x44, 0x5f, 0x25, 0xef, 0x9c, 0x9c, 0xfc, 0x2f, 0x68, 0x96,
    0xb2, 0x7b, 0x28, 0xdd, 0x26, 0x48, 0x4a, 0xe8, 0x71, 0xb7, 0x4f, 0x9b, 0x84, 0xe3, 0xf2, 0x95,
    0x2e, 0x6e, 0x66, 0xf5, 0xbe, 0x27, 0xd5, 0xe0, 0x0a, 0x29, 0xe3, 0x02, 0xa1, 0x60, 0x28, 0x83,
    0x3d, 0xb4, 0xa9, 0xe2, 0xe0, 0x16, 0xaa, 0x10, 0x03, 0x2a, 0x63, 0xeb, 0xda, 0xd2, 0x8a, 0xfd,
    0x7a, 0x6f, 0x11, 0xc9, 0x75, 0xfe, 0xea, 0xa1, 0x0d, 0x89, 0xd3, 0xf4, 0x06, 0x77, 0xbd, 0xcb,
    0x1a, 0xf9, 0x3d, 0x69, 0x14, 0x2a, 0x47, 0x20, 0x3c, 0xde, 0xe5, 0x9d, 0x56, 0x6b, 0xfb, 0x7d,
    0xef, 0x8f, 0xb3, 0x9a, 0xb3, 0x62, 0x7a, 0x59, 0x53, 0x25, 0x08, 0x59, 0x02, 0xf6, 0x7f, 0x92,
    0x64, 0x01, 0xb8, 0x65, 0x60, 0xf5, 0x61, 0x20, 0xfe, 0xa7, 0x2e, 0x23, 0xc2, 0xaa, 0x8a, 0xa4,
    0x6d, 0x02, 0x03, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00    
]

#Use this key for PRMA when production Keys are used
G_ROM_RSA_PRMA_PublicKey = [
    0x30,0x82,0x01,0x22,0x30,0x0D,0x06,0x09,0x2A,0x86,0x48,0x86,0xF7,0x0D,0x01,0x01,
    0x01,0x05,0x00,0x03,0x82,0x01,0x0F,0x00,0x30,0x82,0x01,0x0A,0x02,0x82,0x01,0x01,
    0x00,0xC1,0x9E,0x9F,0xCF,0x84,0x8E,0xD4,0x3A,0x6F,0x94,0xE1,0x41,0xB9,0xAA,0xC6,
    0x3F,0x9B,0x8A,0xBA,0xB0,0x3D,0x24,0xFF,0x33,0x1C,0xCB,0x1C,0x4C,0x97,0xB1,0x5F,
    0x45,0x6D,0x4F,0xBB,0x6B,0x73,0x67,0xAC,0xB1,0x4B,0xBF,0xAB,0xE6,0xA9,0xE1,0x81,
    0x69,0xF3,0xAD,0x30,0x01,0x9C,0x10,0x06,0x9E,0x87,0xE3,0xA5,0xA4,0x9B,0xBF,0xE0,
    0xEA,0xD0,0x0E,0x40,0xCB,0xB8,0x49,0x5E,0x21,0x07,0xC9,0xE6,0x4E,0x36,0x90,0x2A,
    0xFF,0x53,0xF8,0xCC,0x16,0xBF,0x52,0xA7,0xA0,0x74,0x02,0xEE,0xC2,0xD7,0x64,0x0E,
    0x28,0x24,0x61,0x07,0xCC,0xBA,0x1E,0xE4,0xC5,0x29,0x8D,0xCB,0xC8,0x6B,0x55,0xB1,
    0xEA,0xB4,0x18,0xF0,0x0D,0x4C,0xD5,0x2C,0x54,0x6D,0x52,0x59,0xF2,0x25,0xD7,0x20,
    0xDE,0x67,0xE2,0x62,0xC0,0xAA,0xF2,0x69,0xD1,0xE2,0x01,0x7F,0x88,0x86,0x4D,0x2F,
    0x3D,0xF7,0x31,0x44,0xA1,0xE9,0xC8,0x03,0x89,0x93,0xE5,0x70,0x24,0xE9,0xD3,0x3D,
    0x50,0x45,0x15,0x63,0x46,0x9B,0xE0,0x23,0x5B,0x67,0x6D,0x62,0xD7,0xF1,0xE5,0x12,
    0xB2,0x50,0xB9,0xFF,0xDB,0x99,0x62,0x30,0x98,0xC8,0x2D,0x6F,0x77,0x90,0xC8,0x98,
    0x91,0x83,0xE3,0xF5,0x65,0xE4,0xB0,0xFE,0xD7,0x90,0x33,0x6B,0xDA,0x57,0x99,0x04,
    0xD6,0x93,0xB9,0xD9,0x4A,0x5B,0x3F,0x87,0xC9,0x66,0x5F,0x42,0x1A,0x9C,0xDD,0xDD,
    0xE9,0xB5,0x84,0x63,0xA5,0xFF,0x31,0x7C,0xBD,0xFD,0x7A,0x4A,0x41,0x3C,0x7E,0x32,
    0x4B,0x9E,0x0A,0x74,0xF3,0xF5,0x23,0x0E,0xD1,0x00,0xA4,0x7E,0x20,0x0D,0xD8,0x76,
    0xC7,0x02,0x03,0x01,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
]

G_ROM_RSA_LRMA_PublicKey =[
    0x30,0x82,0x01,0x22,0x30,0x0d,0x06,0x09,0x2a,0x86,0x48,0x86,0xf7,0x0d,0x01,0x01,
    0x01,0x05,0x00,0x03,0x82,0x01,0x0f,0x00,0x30,0x82,0x01,0x0a,0x02,0x82,0x01,0x01,
    0x00,0xd6,0xfc,0x88,0x69,0x6f,0x03,0x76,0x6a,0x7b,0x04,0xa9,0x57,0x1b,0xb7,0x42,
    0x99,0xcb,0x7e,0x02,0xf7,0x8b,0x01,0x20,0x16,0x68,0xa6,0xbc,0xe8,0x98,0xbd,0xdf,
    0x98,0xfe,0x38,0x6c,0x40,0xb6,0x69,0x40,0xe7,0x50,0x84,0xe7,0x12,0x29,0x20,0x99,
    0x69,0xcf,0xff,0xa5,0xfe,0xe1,0xe5,0xf7,0xad,0x71,0x58,0xf8,0x08,0xa9,0xf8,0xb3,
    0x15,0xf6,0x05,0xae,0xb8,0x9e,0x99,0x1d,0x87,0xf4,0x1f,0xde,0x3c,0xf6,0xda,0xf6,
    0x22,0xb8,0x22,0x8e,0x53,0xfa,0xbb,0xaa,0x34,0x9b,0x94,0xb4,0x7c,0xf9,0xe0,0x53,
    0x00,0xc1,0x4d,0x3d,0x95,0x9a,0xe7,0x9d,0xaa,0xe0,0x24,0x89,0xbe,0x19,0x65,0x79,
    0x1b,0xd5,0xf6,0x1d,0x26,0x14,0xb0,0x0c,0xda,0x90,0x51,0x59,0x5a,0xe0,0x8d,0x27,
    0x22,0x01,0xab,0xb3,0x3f,0xb1,0x74,0xf5,0xd0,0x7d,0x7a,0x41,0x6e,0x21,0x89,0xe2,
    0xa5,0x32,0xa8,0xd1,0x87,0xa9,0xc1,0xe0,0x12,0xb4,0x76,0xd8,0xe2,0x70,0x44,0x9e,
    0x08,0xbc,0xe3,0xaa,0xa7,0xf0,0xea,0xc6,0x66,0xe2,0x31,0x1a,0x7e,0x4a,0xa4,0x87,
    0x20,0xd7,0xa3,0x73,0x95,0xa9,0xa6,0x1a,0x42,0x9b,0x77,0xe3,0x79,0xe0,0x34,0x28,
    0x65,0xe0,0xf9,0x02,0xfa,0x13,0xe1,0x70,0x67,0x04,0x9c,0xe9,0x76,0x62,0x2a,0xa8,
    0x78,0xfb,0x7e,0xe6,0x78,0x8b,0x7a,0x65,0xbc,0x97,0x2e,0x13,0xfd,0xdb,0x8a,0x41,
    0x91,0x98,0x3d,0x31,0xae,0x24,0x80,0x6f,0x49,0x53,0x7f,0x7b,0x2c,0x28,0x9f,0xd2,
    0x1c,0x6d,0x49,0xe2,0xf2,0xca,0x46,0x56,0x66,0x54,0xe6,0xd2,0x9f,0x7e,0xd4,0x2b,
    0x15,0x02,0x03,0x01,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
]

class RMAUtilities(customize_log):
    """
    Class which has the definitions/functions to test SFFU process.
    """
    def __init__(self,vtfContainer):
        """
        Name        : __init__
        Description : Initializing the pre-requistics to test RMA process.
        Arguments   : randomseed, objApplicationRunAttributes(optional)
        Returns     : None	
        """	
        self.vtfContainer         = vtfContainer
        if self.vtfContainer.isModel:
            self.livet = self.vtfContainer._livet   
            self.livetFlash = self.vtfContainer._livet.GetFlash()
            self.model = self.livet.GetFirmwareInterface()
        self.__logger            = self.vtfContainer.GetLogger()
        #self.__randomObj         = randomObj
        #self.__optionValues      = optionValues
        #self.__eFuseUtilsObj     = EFUSEUtils.EFUSEUtils(self.vtfContainer)
        #self.__livet             = self.vtfContainer.Livet
        self.__decodedR1response = None
        
        ###### Creating CVF objects ######
        self.vtfContainer = vtfContainer
        self.currCfg = Configuration.ConfigurationManagerInitializer.ConfigurationManager.currentConfiguration
        self.CVFTestFactory = FactoryMethod.CVFTestFactory().GetProtocolLib()
        self.__TF = self.CVFTestFactory.TestFixture
        self.__ErrorManager = self.vtfContainer.device_session.GetErrorManager()        

        #if not self.__optionValues.botfilename:
            #raise TestError.TestFailError("","--Error: BotFile path is missing in Cmd Line Args.")


        #Class Variables
        self.currentDeviceChallenge = None
        self.currentDeviceChallengeCounter = None
        self.publicKeySize = None
        self.RMA = None
        self.currentDeviceState = 0x01

        #Keep Private key
        #Using the following key as directed by FW, for now:
        #keys_path = os.path.join(os.getenv('SANDISK_FW_VALIDATION'),'TestCases\\ROMTests\\Security\\Keys')
        #privatekeyfilepath = os.path.join(keys_path,'key_P19_O2_T1_SBSK_0.pem')
        #with file(privatekeyfilepath, 'r') as f:
            #self.private_key = f.read()

        #self.private_key = RSA.importKey(self.private_key)
        
        ###### Customize Log ######
        self.fn = os.path.basename(getframeinfo(currentframe()).filename)
        customize_log.__init__(self, self.__TF)        

    #End of  __init__

    def FromHexStringArrayToByteArray(self, hexStr):
    
        tmp = hexStr.decode("ascii")
        tmpArr = array.array('B')
        count = 0
        while count + 1 < len(tmp):
            i = int(tmp[count], 16) << 4
            i |= int(tmp[count + 1], 16)
            count +=2
            tmpArr.append(i)
        if (len(tmp)%2 != 0):
            i = int(tmp[count], 16)
            tmpArr.append(i)
        return tmpArr

    def GetDeviceChallenge(self, rma='BRMA', signed=True):
        """
        """
        opcode = 0x40
        subOpcode = 0x00
        option = {'PRMA': 0x0, 'LRMA' : 0x1, 'BRMA' : 0x2}.get(rma)
        #Invalid RMA option
        if option==None:
            option=0x3
        cdb = [ opcode, subOpcode,option, 0,
                0, 0, 0, 0,
                0, 0, 0, 0,
                0, 0, 0, 0
                ]
        #Form Signed SCTP CDB
        if signed:
            cdb = self.FormSignedSCTP(cdb)
        dataBuffer = DiagnosticLib.GetDeviceChallenge(self.vtfContainer, cdb)[0]

        cid = dataBuffer.GetRawString(0, 13, little_endian=True)
        self.publicKeySize = dataBuffer.GetTwoBytesToInt(13)
        #newDeviceChallenge = dataBuffer.GetRawString(15, 32, little_endian=True)
        rsa_pub_key = dataBuffer.GetRawString(47, 256, little_endian=True)
        newRunningCounter = dataBuffer.GetFourBytesToInt(15) #Get actual integer because it's in little endian
        
        newDeviceChallenge = pyWrap.Buffer.CreateBuffer(1)
        newDeviceChallenge.Copy(0,dataBuffer,15,32)
        

        #cid = cid.encode('hex')
        #newDeviceChallenge = newDeviceChallenge.encode('hex')
        #rsa_pub_key = rsa_pub_key.encode('hex')	

        #self.__logger.Info("","Previous Counter :"+ str(self.currentDeviceChallengeCounter))
        self.infoLog(self.fn, currentframe().f_lineno, sys._getframe().f_code.co_name, "Previous Counter: %s" % str(self.currentDeviceChallengeCounter))
        #self.__logger.Info("","New Counter :"+ str(newRunningCounter))
        self.infoLog(self.fn, currentframe().f_lineno, sys._getframe().f_code.co_name, "New Counter: %d" % int(newRunningCounter))
        

        #self.__logger.Info("","Previous challenge : "+ str(self.currentDeviceChallenge))
        self.infoLog(self.fn, currentframe().f_lineno, sys._getframe().f_code.co_name, "Previous challenge: %s" % str(self.currentDeviceChallenge))
        
        #self.__logger.Info("","New challenge : "+ str(newDeviceChallenge))
        self.infoLog(self.fn, currentframe().f_lineno, sys._getframe().f_code.co_name, "New challenge : %s" % str(newDeviceChallenge))


        if self.currentDeviceChallengeCounter is not None and newRunningCounter != self.currentDeviceChallengeCounter + 1:
            raise TestError.TestFailError("","Running counter was expected to be "+ str(self.currentDeviceChallengeCounter + 1) )

        if newDeviceChallenge == self.currentDeviceChallenge:
            raise TestError.TestFailError("","Challenge did not change with repeated GDC issuance")

        self.currentDeviceChallenge = newDeviceChallenge
        self.currentDeviceChallengeCounter = newRunningCounter
        self.RMA = rma
        return self.currentDeviceChallenge
    def GenerateKDFPin(self, nounce ,option,iterations=10000):
        self.infoLog(self.fn, currentframe().f_lineno, sys._getframe().f_code.co_name,"Generation of RMA Pin in Progress")

        #Nonce and PSIDPassword is ASCII values in this example.
        #i.e ASCII value of 0 (1 digit) is 0x30 in hex (2 byte value) .
        #In Host, Const challenge should be 0x30. For 32-byte challange, use 32 'zero's
        # Need to check how to give key and nonce which is not of ascii character
        #Fixed Challenge
        #uint8 fixed_challange[28] = { 0x00, 0x00, 0x00, 0x00, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b };

        #Keep the const GDC value in hex values and call FromHexStringArrayToByteArray(fixedNonce) when using pbkdf2_hmac
        # Same should be done for password also. so that password can be read from agile.
        #fixedNonce = "00000000000000000405060708090a0b0c0d0e0f101112131415161718191a1b"
        #Nonce1 = self.HexToAscii(fixedNonce)
        #print("\n" + binascii.hexlify(bytearray(Nonce1)) + "\n")

        PSIDPassword="0000000000000000000000000000000000000000000000000000000000000000"
    

        nounceSize = 0x20 #32-byte challange 4-byte (counter) + 28-byte(random number)

        nonce_Str = ""
        for i in range (0,32):
            hex_str = hex(nounce.GetByte(i))[2:]
            if(len(hex_str) == 1):
                hex_str = "0"+hex_str
            nonce_Str += hex_str

        pwd_Str = ""
        for i in range(0,64):
            index = 32 #start from 32 index of public key
            #hex_str = hex(G_ROM_RSA_PRMA_PublicKey[i])[2:]
            
            if option == 0:
                hex_str = hex(G_ROM_RSA_PRMA_PublicKey[index+i] ^ nounce.GetByte(i % 32))[2:]
            elif option == 1:
                hex_str = hex(G_ROM_RSA_LRMA_PublicKey[index+i] ^ nounce.GetByte(i % 32))[2:]
            if(len(hex_str) == 1):
                hex_str = "0"+hex_str
            pwd_Str += hex_str



        try:
            #password_hash = hashlib.pbkdf2_hmac('sha256', FromHexStringArrayToByteArray(binascii.hexlify(bytearray(PSIDPassword))), FromHexStringArrayToByteArray(binascii.hexlify(bytearray(Nonce))), 1)
            #password_hash = hashlib.pbkdf2_hmac('sha256', self.FromHexStringArrayToByteArray(binascii.hexlify(bytearray(PSIDPassword))), self.FromHexStringArrayToByteArray(nonce_Str), 1)
            password_hash = hashlib.pbkdf2_hmac('sha256', self.FromHexStringArrayToByteArray(bytearray(pwd_Str, "latin-1")), self.FromHexStringArrayToByteArray(bytearray(nonce_Str, "latin-1")), iterations)

            print(binascii.hexlify(password_hash))

            self.infoLog(self.fn, currentframe().f_lineno, sys._getframe().f_code.co_name,"Generation of RMA Pin SUCCESS!!")

            return binascii.hexlify(password_hash)
        except Exception as ex:
            print("Unable to generate  RMA Pin {0}" .format(ex.message)) 

    def GenerateKDFPin_with_DifferentKey(self, nounce ,unlock_key,iterations=10000):
        print ("Generation of RMA Pin in Progress")

        #Nonce and PSIDPassword is ASCII values in this example.
        #i.e ASCII value of 0 (1 digit) is 0x30 in hex (2 byte value) .
        #In Host, Const challenge should be 0x30. For 32-byte challange, use 32 'zero's
        # Need to check how to give key and nonce which is not of ascii character
        #Fixed Challenge
        #uint8 fixed_challange[28] = { 0x00, 0x00, 0x00, 0x00, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b };

        #Keep the const GDC value in hex values and call FromHexStringArrayToByteArray(fixedNonce) when using pbkdf2_hmac
        # Same should be done for password also. so that password can be read from agile.
        #fixedNonce = "00000000000000000405060708090a0b0c0d0e0f101112131415161718191a1b"
        #Nonce1 = self.HexToAscii(fixedNonce)
        #print("\n" + binascii.hexlify(bytearray(Nonce1)) + "\n")

        PSIDPassword="0000000000000000000000000000000000000000000000000000000000000000"
    

        nounceSize = 0x20 #32-byte challange 4-byte (counter) + 28-byte(random number)

        nonce_Str = ""
        for i in range (0,32):
            hex_str = hex(nounce.GetByte(i))[2:]
            if(len(hex_str) == 1):
                hex_str = "0"+hex_str
            nonce_Str += hex_str

        pwd_Str = ""
        for i in range(0,64):
            index = 32 #start from 32 index of public key
            #hex_str = hex(G_ROM_RSA_PRMA_PublicKey[i])[2:]
            if unlock_key == 0:
                hex_str = hex(G_ROM_RSA_PRMA_PublicKey[index+i] ^ nounce.GetByte(i % 32))[2:]
            elif unlock_key == 1:
                hex_str = hex(G_ROM_RSA_LRMA_PublicKey[index+i] ^ nounce.GetByte(i % 32))[2:]
            if(len(hex_str) == 1):
                hex_str = "0"+hex_str
            pwd_Str += hex_str



        try:
            #password_hash = hashlib.pbkdf2_hmac('sha256', FromHexStringArrayToByteArray(binascii.hexlify(bytearray(PSIDPassword))), FromHexStringArrayToByteArray(binascii.hexlify(bytearray(Nonce))), 1)
            #password_hash = hashlib.pbkdf2_hmac('sha256', self.FromHexStringArrayToByteArray(binascii.hexlify(bytearray(PSIDPassword))), self.FromHexStringArrayToByteArray(nonce_Str), 1)
            password_hash = hashlib.pbkdf2_hmac('sha256', self.FromHexStringArrayToByteArray(bytearray(pwd_Str, "latin-1")), self.FromHexStringArrayToByteArray(bytearray(nonce_Str, "latin-1")), iterations)

            print(binascii.hexlify(password_hash))

            print("Generation of RMA Pin SUCCESS!!")

            return binascii.hexlify(password_hash)
        except Exception as ex:
            print("Unable to generate  RMA Pin {0}" .format(ex.message))    


    def SignDeviceChallenge(self, devicechallenge):
        '''
        For engg keys, we can use the OpenSSL API to call for signature using the private key
        For Release keys, will have to call the signing server
        '''
        devicechallenge = self.FromHexStringArrayToByteArray(devicechallenge)
        digest = SHA256.new(bytearray(devicechallenge))
        signedchallenge = PKCS1_v1_5.new(self.private_key).sign(digest)
        signedchallenge = signedchallenge.encode('hex')	 

        return signedchallenge    

    def Unlock(self,challenge, rmaOption, corrupt = False, signed=True,iterations=10000):
        '''
        Write
        Fill Buf:

        Byte 0-1     : Key size (little endian)
        Byte 2-257   : RSA signed challenge
        Byte 257-511 : Padded with 0x0
        '''
        opcode = 0x41
        subOpcode = 0x00
        option = {'PRMA': 0x0, 'LRMA' : 0x1, 'BRMA' : 0x2}.get(rmaOption)
        cdb = [ opcode, subOpcode,option, 0,
                0, 0, 0, 0,
                0, 0, 0, 0,
                0, 0, 0, 0
                ]
        if signed:
            cdb = self.FormSignedSCTP(cdb)
            
        KDFPIN = pyWrap.Buffer.CreateBuffer(1)
            
        if option == 0 or option == 1:
            rmapin = self.GenerateKDFPin(challenge,option)
        cdb = [ opcode, subOpcode,option, 0,
                0, 0, 0, 0,
                0, 0, 0, 0,
                0, 0, 0, 0
                ]
        if signed:
            cdb = self.FormSignedSCTP(cdb)
            
        KDFPIN = pyWrap.Buffer.CreateBuffer(1)
            
        if option == 0 or option == 1:
            rmapin = self.GenerateKDFPin(challenge,option,iterations)
            byteArrayrmaPin = self.FromHexStringArrayToByteArray(rmapin)
            for i, data in enumerate(byteArrayrmaPin):
                KDFPIN.SetByte(2+i, data)                
            
        else:
            print("\nfor BRMA, secure server signing is required\n")        

        #dataBuffer = pyWrap.Buffer.CreateBuffer(SINGLE_SECTOR,0)
        KDFPIN.SetTwoBytes(0,self.publicKeySize)
        #signedchallenge_bytes = self.FromHexStringArrayToByteArray(signedchallenge)
        if corrupt:
            KDFPIN.SetByte(2,0xFF)	

        DiagnosticLib.Unlock(self.vtfContainer, KDFPIN, cdb)

        return



    def Unlock_different_key(self,challenge, rmaOption,unlock_key, corrupt = False, signed=True,iterations=10000):
        '''
        Write
        Fill Buf:

        Byte 0-1     : Key size (little endian)
        Byte 2-257   : RSA signed challenge
        Byte 257-511 : Padded with 0x0
        '''
        opcode = 0x41
        subOpcode = 0x00
        option = {'PRMA': 0x0, 'LRMA' : 0x1, 'BRMA' : 0x2}.get(rmaOption)
        unlock_key = {'PRMA': 0x0, 'LRMA' : 0x1, 'BRMA' : 0x2}.get(unlock_key)
        cdb = [ opcode, subOpcode,option, 0,
                0, 0, 0, 0,
                0, 0, 0, 0,
                0, 0, 0, 0
                ]
        if signed:
            cdb = self.FormSignedSCTP(cdb)
            
        KDFPIN = pyWrap.Buffer.CreateBuffer(1)
            
        if option == 0 :
            rmapin = self.GenerateKDFPin_with_DifferentKey(challenge,unlock_key,iterations)
            byteArrayrmaPin = self.FromHexStringArrayToByteArray(rmapin)
            for i, data in enumerate(byteArrayrmaPin):
                KDFPIN.SetByte(2+i, data)                
            
        else:
            print("\nfor BRMA, secure server signing is required\n")        

        #dataBuffer = pyWrap.Buffer.CreateBuffer(SINGLE_SECTOR,0)
        KDFPIN.SetTwoBytes(0,self.publicKeySize)
        #signedchallenge_bytes = self.FromHexStringArrayToByteArray(signedchallenge)
        if corrupt:
            KDFPIN.SetByte(2,0xFF)	

        DiagnosticLib.Unlock(self.vtfContainer, KDFPIN, cdb)

        return

    def MoveToLock(self):
        """
        """
        DiagnosticLib.MoveToLock(self.vtfContainer)
        Utils.PowerCycle(self.vtfContainer)
        self.currentDeviceState = 0x1
        return

    def GetDeviceState(self, signed=False, corrupt=False):
        """
        """
        opCode = 0x43
        subOpcode = 0x0
        options = 0x0	
        cdb = [opCode,subOpcode,options,0,0,0,0,0,0,0,0,0,0,0,0,0]
        #Form Signed SCTP CDB
        if signed:
            cdb = self.FormSignedSCTP(cdb,corrupt)

        self.currentDeviceState = DiagnosticLib.GetDeviceState(self.vtfContainer, cdb)


        return DEVICESTATES[self.currentDeviceState]

    def FormSignedSCTP(self, cdb, corrupt=False):
        '''
        Approach for now:
        Create a separate  API (FormSignedSCTP) 
        Call: FormSignedSCTP(cdb) pass the cdb buffer created previously
        Inside FormSignedSCTP append RSA signature to cdb buffer. ( Also make cdb size = 432)
        -----------------------------------------------  |
        CDB (16B)                                        |
        -----------------------------------------------  | 432 Bytes
        APPLICATION SPECIFIC DATA (160B)                 |
        -----------------------------------------------  |
        SIGNATURE (256B)Signed with Product Private Key  |

        RSA signature to be obtained by RSA(SHA256(SCTP sign + App Sign), private key) 
        '''
        app_specific_data = [0] * 160; #App Specific data is 416 bytes excluding CDB, including CDB, it is 432 bytes
        #For Signed SCTP, set the final 256 bytes with RSA signature value
        #sctp_rsa_signature = self.GetSCTPRSASignature()
        #Extend app specific data, include sctp sign
        #sctp_rsa_signature_Hex = ''.join(x.encode('hex') for x in sctp_rsa_signature)
        #sctp_rsa_signature_bytes = self.FromHexStringArrayToByteArray(sctp_rsa_signature_Hex)

        #Comment this hardcoded signature and use our own calculated signature once Private keys are known.
        #Otherwise don't make it complex, take final precomputed signature from FW and hard code it.
        """
	sctp_rsa_signature_bytes = [
               0xb6, 0xa1, 0xf5, 0xba, 0xfe, 0xd8, 0xff, 0x24, 0x20, 0x7f, 0x19, 0x4f, 0x8d, 0x9e, 0x00, 0x88,
               0x2f, 0xb9, 0x0a, 0x9e, 0x83, 0x53, 0x44, 0xe6, 0x4d, 0xcd, 0xb2, 0x79, 0x9d, 0xd8, 0x4d, 0x49,
               0xb5, 0x82, 0xfb, 0x1e, 0xd8, 0x40, 0x5d, 0x9c, 0x6f, 0xc7, 0x9e, 0x58, 0x55, 0xe5, 0xb5, 0x40,
               0x9e, 0x4b, 0x67, 0xb3, 0xd7, 0x17, 0x79, 0x9a, 0x7d, 0x97, 0xae, 0x84, 0x48, 0xf3, 0xf4, 0x0a,
               0xc9, 0x61, 0xf6, 0xdc, 0xe5, 0x6f, 0xfa, 0xea, 0x30, 0xbf, 0x43, 0x07, 0xa8, 0x4d, 0xb2, 0x27,
               0x6d, 0x49, 0x59, 0x4b, 0x42, 0xc2, 0x70, 0x1b, 0x5e, 0x62, 0xa7, 0x93, 0x15, 0x9f, 0x19, 0xe7,
               0xd0, 0xa2, 0x98, 0x56, 0x22, 0x5c, 0xaa, 0x03, 0x3c, 0x0d, 0x54, 0xaa, 0xaa, 0x6d, 0x3f, 0xa5,
               0x3c, 0x52, 0xf1, 0x98, 0xc5, 0xd3, 0x3b, 0x9d, 0x1f, 0x17, 0xe3, 0x10, 0x48, 0xd7, 0xbc, 0x2c,
               0xcc, 0x88, 0x30, 0x1b, 0x52, 0xb8, 0xe3, 0x83, 0xe8, 0x25, 0xa0, 0xed, 0x03, 0x81, 0xb7, 0xe0,
               0xa5, 0x1f, 0x66, 0x2d, 0x00, 0xac, 0xf7, 0x3d, 0x51, 0xd6, 0xce, 0x99, 0x51, 0xbd, 0x85, 0x9f,
               0x1b, 0x61, 0xd2, 0xe1, 0x8c, 0x4e, 0xf5, 0x7d, 0xe5, 0xa2, 0x0e, 0x87, 0xe8, 0x6b, 0x3c, 0x99,
               0xd2, 0xf3, 0x29, 0xc3, 0x3e, 0x1f, 0xfe, 0x30, 0x69, 0x64, 0xb2, 0xb5, 0xa8, 0xb4, 0xbb, 0x30,
               0xc9, 0x50, 0x94, 0x28, 0x91, 0x73, 0x93, 0xf1, 0x00, 0x81, 0x0b, 0xfc, 0x15, 0x0f, 0x41, 0xd6,
               0x2a, 0x65, 0x49, 0x6b, 0xa4, 0x8f, 0x64, 0xea, 0x8c, 0x38, 0x31, 0x8b, 0x2e, 0xc9, 0xe7, 0x6d,
               0xe1, 0x2b, 0x41, 0x54, 0x69, 0xbb, 0xe5, 0x33, 0x95, 0xda, 0xdd, 0x3d, 0xad, 0x33, 0x08, 0xa7,
               0x7b, 0x5a, 0xb4, 0x40, 0x73, 0xea, 0x7c, 0x61, 0xa5, 0x79, 0x9a, 0xd7, 0xe3, 0x12, 0xa5, 0xef]
	"""
        #SCTP from release keys
        global SCTP_RSA_Signature
        		

        app_specific_data.extend(SCTP_RSA_Signature[self.vtfContainer.isModel])
        if corrupt:
            app_specific_data[161] = app_specific_data[161] ^ 0xFF        
        #Add the app specific data to the cdb
        cdb.extend(app_specific_data)
        return cdb

    def GetSCTPRSASignature(self):
        '''
        SCTP Signature (32 bytes):
        { 0xdd, 0x4c, 0x02, 0xd8, 0x0f, 0xf5, 0x0a, 0x70, 0x5e, 0x7f, 0x5a, 0x84, 0xc6,
        0xf7, 0x4b, 0x6b, 0xd2, 0x42, 0x71, 0x28, 0x46, 0x42, 0x7b, 0x89, 0x7d, 0x8c, 0x55, 0x7c, 0x3a, 0x5a, 0x30, 0x39 }

        Application Signature (32 bytes):
        { 0x10, 0x25, 0x42, 0xeb, 0x4e, 0x10, 0x90, 0x8f, 0x4b, 0x45, 0x6f, 0x88, 0x4f,
        0xf2, 0x9f, 0x61, 0x5d, 0xec, 0x18, 0xd2, 0x2b, 0x71, 0x60, 0xf4, 0xbe, 0x58, 0xcb, 0x04, 0x87, 0xf7, 0xcf, 0x94 }

        Generated 32 byte Hash using SHA256:
        hash32 = 55b452ccf71c9343fb1747be97262d08f7ca216da973a372f762d597a9289ded
        '''
        #Hardcoding it since the diag data will be constant
        hash32 = '55b452ccf71c9343fb1747be97262d08f7ca216da973a372f762d597a9289ded'
        #Generate 256 Bytes RSA signature:
        pkey = crypto.load_privatekey(crypto.FILETYPE_PEM, self.private_key)
        sctp_rsa_signature = crypto.sign(pkey, hash32, 'sha256')

        return sctp_rsa_signature

    def SignedWritePort(self,addr,byteCount,buf, signed=False, corrupt=False):
        """  
        Description:
           * Writes data to the given RAM location
        """
        import ByteUtil
        commandName = "WritePort"
        opcode    = 0x8C  
        cdb = [opcode,0x0,0x0,0x0, 
               ByteUtil.LowByte(ByteUtil.LowWord(addr)),ByteUtil.HighByte(ByteUtil.LowWord(addr)),
                       ByteUtil.LowByte(ByteUtil.HighWord(addr)),ByteUtil.HighByte(ByteUtil.HighWord(addr)),
                       ByteUtil.LowByte(ByteUtil.LowWord(byteCount)),ByteUtil.HighByte(ByteUtil.LowWord(byteCount)),
                       ByteUtil.LowByte(ByteUtil.HighWord(byteCount)),ByteUtil.HighByte(ByteUtil.HighWord(byteCount)), 
                       0x0,0x0,0x0,0x0]
        if signed:
            cdb = self.FormSignedSCTP(cdb, corrupt)
        WRITE_DATA=0x1
        SINGLE_SECTOR=0x01
        DiagnosticLib.SendDiagnostic(self.vtfContainer, buf, cdb, WRITE_DATA, SINGLE_SECTOR, opcode, commandName)

        return  

    def GetEfuseBit(self, bit):
        EfuseData = DiagnosticLib.GetEFuseData(self.vtfContainer)
        efuse_int= EfuseData.GetFourBytesToInt(old_div(bit,32)*4)
        efuse_int_hex="%08X"%efuse_int	
        if bit==244:
            #for i in EfuseData:
                #self.__logger.Info(""," 0x%08X  "%i)
            EfuseData.PrintToLog()

            #self.infoLog(self.fn, currentframe().f_lineno, sys._getframe().f_code.co_name, "SPR and RMA bit corresponds to : %s " % efuse_int_hex)

        #Get byte position in int
        #bit%32= pos in this int= this gives 25th  , %4= which number in int = 6 (starting backwards- we get 0- 0x1"0"8600c4)

        pos= bit %32
        int_pos= old_div(pos,4)
        bin_pos= pos%4
        Byte= int(efuse_int_hex[-(int_pos+1)], 16)
        mask= 1<<bin_pos


        bit_set= Byte & mask
        if bit_set:
            bit_set=1
        #self.__logger.Info("","Efuse %d bit: %d"%(bit,bit_set))
        return bit_set

    def GeEfuseBasedState(self):
        SPR=[244,245,246]
        RMA=[247,248,249]

        SPR_bits=[]
        RMA_bits=[]
        for i in SPR:
            bit= self.GetEfuseBit(i)
            SPR_bits.append(bit)
            #self.infoLog(self.fn, currentframe().f_lineno, sys._getframe().f_code.co_name,"%d bit: %d" % (i,bit))
        for i in RMA:
            bit= self.GetEfuseBit(i)
            RMA_bits.append(bit)
            #self.infoLog(self.fn, currentframe().f_lineno, sys._getframe().f_code.co_name,"%d bit: %d"%(i,bit))

        MajoritySPR= max(set(SPR_bits), key = SPR_bits.count)
        MajorityRMA= max(set(RMA_bits), key = RMA_bits.count)

        # Need to check RMA bit
        str_state=  str(MajorityRMA)+ str(MajoritySPR)
        states={'00': 0x0, '01':0x1, '10':0x2, '11':0x3}
        cur_state= states[str_state]
        #self.infoLog(self.fn, currentframe().f_lineno, sys._getframe().f_code.co_name,"Efuse State: %s "%DEVICESTATES[cur_state])
        #self.__logger.Info("","Efuse State: %s "%DEVICESTATES[cur_state])
        return DEVICESTATES[cur_state]
    
    def UnlockCard(self, UnlockOption, ChallengeBuf, UnlockKey=None, iterations=10000):
        #SEC_RMA_MODE_PRODUCTION_UNLOCK,      /*0, For re-download process in LOCKED state.*/
        #SEC_RMA_MODE_LITTLE_UNLOCK,          /*1, For enabling RO diagnostic in LOCKED state*/
        option = {'PRMA': 0x0, 'LRMA' : 0x1, 'BRMA' : 0x2}.get(UnlockOption)
        try:
            # Diagnostic read/write unit test
            cmd = 0x41
            option = option
            length = 0x200
            db = self.makeSCTPCommand(0, cmd, length, option)
            #cmd = makeSCTPLba(cmd)

            self.infoLog(self.fn, currentframe().f_lineno, sys._getframe().f_code.co_name,"++ Sending UnlockCard command")

            for i, data in enumerate(SCTP_RSA_Signature[0]):
                db.SetByte(256+i, data)

            #writeData(cmd, 1, db)
            writeSingleBlockCommand = sdcmdWrap.WriteSingleBlock(startLba= cmd, 
                                                                bNoData= True,
                                                                szBuffer= db,
                                                                sendType = ServiceWrap.CMD_SEND_TYPE.SEND_NONE)
            writeSingleBlockCommand.Execute()            


            #ChallengeBuf = [0x00, 0x02, 0xae, 0x45, 0xfd, 0x9e, 0x61, 0x83, 0xa6, 0x6c, 0xd4, 0x2b, 0x81, 0xb9, 0xab, 0x9f, 0xec, 0x84, 0x29, 0x04, 0x88, 0x0c, 0xb7, 0x7b, 0x91, 0xd8, 0x02, 0x81, 0xb4, 0x44, 0xff, 0x6e, 0x1d, 0x90, 0x3a, 0xac, 0xaa, 0xaa, 0xe1, 0x07, 0x06, 0xdb, 0xd0, 0x5f, 0xe0, 0x01, 0xf6, 0x4d, 0x69, 0x3a, 0xca, 0xc6, 0x99, 0x27, 0x9f, 0xad, 0x32, 0x99, 0xf9, 0x0e, 0x66, 0x6b, 0xb2, 0x16, 0x5d, 0xba, 0x8b, 0xb4, 0x2f, 0x0d, 0x29, 0x2c, 0xfb, 0x96, 0x3c, 0x0b, 0x2d, 0x07, 0xe1, 0xd7, 0xe6, 0xbb, 0x8e, 0x79, 0x64, 0x93, 0x1e, 0x7e, 0xd3, 0x27, 0xde, 0x50, 0xdd, 0x7c, 0x68, 0xf6, 0x14, 0x75, 0x3a, 0xa4, 0xf8, 0x76, 0x1c, 0x80, 0xbd, 0xd1, 0x74, 0x0d, 0x15, 0x62, 0xa2, 0x12, 0x61, 0x95, 0xb1, 0x52, 0x28, 0x7d, 0xa0, 0xb0, 0x3f, 0x6b, 0x52, 0xa5, 0x27, 0xd3, 0x3b, 0x07, 0xae, 0x36, 0x86, 0x0a, 0x82, 0x38, 0x85, 0x81, 0xb9, 0xba, 0xa2, 0x95, 0x17, 0x62, 0x8d, 0x19, 0x7a, 0x9e, 0xfc, 0x7d, 0x8f, 0x41, 0x14, 0xf7, 0x28, 0x3c, 0x75, 0x4f, 0x53, 0x26, 0xaf, 0x73, 0x64, 0xde, 0x5d, 0xde, 0xd3, 0xbd, 0x3b, 0xaa, 0xd8, 0x89, 0x7b, 0xac, 0x97, 0x4c, 0x99, 0xc1, 0x15, 0xee, 0x9e, 0xc5, 0xf5, 0xcb, 0x74, 0xef, 0x48, 0x5b, 0x88, 0xbd, 0x8e, 0xe8, 0x05, 0xa5, 0xf9, 0x61, 0x3a, 0x90, 0xcd, 0x47, 0x1a, 0x4b, 0x39, 0x47, 0x86, 0x45, 0x3d, 0x02, 0xec, 0x27, 0x4f, 0x40, 0x10, 0x43, 0xbe, 0x1f, 0x98, 0xbe, 0xa1, 0x35, 0x3b, 0xe7, 0x1d, 0x0d, 0xbc, 0xb0, 0xb3, 0x91, 0x46, 0x67, 0xdd, 0xbd, 0x89, 0x63, 0x11, 0xcf, 0x7b, 0xce, 0x5b, 0xd2, 0x96, 0x9f, 0x42, 0xdb, 0x5a, 0xf6, 0x6b, 0x6e, 0x96, 0x61, 0x1a, 0x05, 0x7f, 0x61, 0xd9, 0x91, 0x5a, 0x73, 0xb9, 0xf9]       

            # For LRMA and PRMA, using KDF
            KDFPIN = ServiceWrap.Buffer.CreateBuffer(1,512)
            if UnlockKey == None:                
                if option == 0 or option == 1:
                    rmapin = self.GenerateKDFPin(ChallengeBuf,option,iterations)
                    byteArrayrmaPin = self.FromHexStringArrayToByteArray(rmapin)
                    KDFPIN.SetByte(0, 0x00)
                    KDFPIN.SetByte(1, 0x02)
                    for i, data in enumerate(byteArrayrmaPin):
                        KDFPIN.SetByte(2+i, data)            
                else:
                    self.infoLog(self.fn, currentframe().f_lineno, sys._getframe().f_code.co_name,"\nfor BRMA, secure server signing is required\n")
            else:
                option = {'PRMA': 0x0, 'LRMA' : 0x1, 'BRMA' : 0x2}.get(UnlockKey)
                if option == 0 or option == 1:
                    rmapin = self.GenerateKDFPin(ChallengeBuf,option,iterations)
                    byteArrayrmaPin = self.FromHexStringArrayToByteArray(rmapin)
                    KDFPIN.SetByte(0, 0x00)
                    KDFPIN.SetByte(1, 0x02)
                    for i, data in enumerate(byteArrayrmaPin):
                        KDFPIN.SetByte(2+i, data)            
                else:
                    self.infoLog(self.fn, currentframe().f_lineno, sys._getframe().f_code.co_name,"\nfor BRMA, secure server signing is required\n")                
            

            #writeData(cmd, 1, db)
            writeSingleBlockCommand = sdcmdWrap.WriteSingleBlock(startLba= cmd, 
                                                                bNoData= True,
                                                                szBuffer= KDFPIN,
                                                                sendType = ServiceWrap.CMD_SEND_TYPE.SEND_NONE)
            writeSingleBlockCommand.Execute()

            #readData(cmd, 1, db)  # status phase
            readSingleBlockCommand = sdcmdWrap.ReadSingleBlock(startLba= cmd,
                                                              bNoData= True,
                                                              szBuffer =db,
                                                              sendType = ServiceWrap.CMD_SEND_TYPE.SEND_NONE)
            readSingleBlockCommand.Execute()


            status = db.GetFourBytesToInt(0x4C)
            if status != 0:
                self.infoLog(self.fn, currentframe().f_lineno, sys._getframe().f_code.co_name,"UnlockCard command NOT executed successfully- 0x%X" % (status))
                return status
            else:
                self.infoLog(self.fn, currentframe().f_lineno, sys._getframe().f_code.co_name,"UnlockCard command executed successfully")
                return status

        except:
            self.infoLog(self.fn, currentframe().f_lineno, sys._getframe().f_code.co_name,"!!!Error occurred during unit test command!!!")
        
    def makeSCTPCommand(self, IsRead, Opcode, DataLen=0x200, Subopcode=0, dwordParam=0, bytecount=0):
        ''' Construct a SCTP command frame.  '''
        # 00 32 bytes SCTP Signature
        # 20 32 bytes Application Signature: Diagnostic App
        # 40 4  bytes tag 
        # 44 4  bytes Offset to LBA
        # 48 1  byte delay sectors before data transfer
        # 49 1  byte delay sectors after data transfer
        # 4a 1  byte Control flag 1 <- 00 = write, 01 = read
        # 4b 1  byte Control flag 2
        # 4c 4  bytes Transfer Length of following Data Phase
        # ---- Application specific bytes (CDB). Refer to FBCC/SCTP command spec
        # 50 16 bytes command:
        # 50 1  Opcode
        #                     8f: Format
        #                     70: GetFormatStatus
        #                     ec: IdentifyDrive
        # 51 1  Chip (unused)
        # 52 1  Subopcode (low byte)
            # 53 1  
        # 54 1  byte 0 of optional 4-byte parameter
        # 55 1  byte 1 of optional 4-byte parameter
        # 56 1  byte 2 of optional 4-byte parameter
        # 57 1  byte 3 of optional 4-byte parameter
    
        # Platform-independent way of extracting the bytes from dword
        # in little-endian order, which is target processor's byte order
        packedDwordParam = pack('<l', dwordParam)
        bytes = unpack('4b', packedDwordParam)
    
        sctp_command_frame = '''
         dd 4c 02 d8 0f f5 0a 70 5e 7f 5a 84 c6 f7 4b 6b
         d2 42 71 28 46 42 7b 89 7d 8c 55 7c 3a 5a 30 39
         10 25 42 eb 4e 10 90 8f 4b 45 6f 88 4f f2 9f 61
         5d ec 18 d2 2b 71 60 f4 be 58 cb 04 87 f7 cf 94
         00 00 00 00 00 00 00 00 00 00 %s 00 00 02 00 00
         %s 00 %s 00 %s %s %s %s 00 00 00 00 00 00 00
         ''' % (hex(IsRead),
             hex(Opcode), 
             hex(Subopcode), 
             hex(bytes[0]), 
             hex(bytes[1]),
             hex(bytes[2]),
             hex(bytes[3]))
    
        # Poke the command frame into a datablock and return it
        db = ServiceWrap.Buffer.CreateBuffer(1,512)
        for i, data in enumerate(sctp_command_frame.split()):
            db.SetByte(i, int(data, 16))

        # Set the length of the next phase.
        db.SetFourBytes(0x4c, DataLen)
        
        #update bytecount
        db.SetFourBytes(0x58, bytecount)
        #Clear xaddress
        db.SetFourBytes(0x5C, 0)        
        
        #db.Dump()
    
        return db
    
    def DoPowerCycle(self, force_download=0):
        self.infoLog(self.fn, currentframe().f_lineno, sys._getframe().f_code.co_name, "~~~ PowerCycle HW - Begin ~~~\n")
        #Power Off
        sdcmdWrap.SetPower(0)

        #Power On
        sdcmdWrap.SetPower(1)

        #Call SDInit
        sdcmdWrap.WrapSDRSystemInit()
        sdcmdWrap.WrapSDCardInit()
        time.sleep(4)
        self.infoLog(self.fn, currentframe().f_lineno, sys._getframe().f_code.co_name, "~~~ PowerCycle HW - End ~~~\n")
    #End of DoPowerCycle()      